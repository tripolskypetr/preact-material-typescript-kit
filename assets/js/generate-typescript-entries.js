(function (global) {

  const applyUserGesture = () => new Promise((resolve) => {
    alert('Click on web page to continue');
    const handler = () => {
      document.body.removeEventListener('click', handler);
      resolve();
    }
    document.body.addEventListener('click', handler, false);
  });

  const loadClosureExterns = () => new Promise((resolve) => {
    alert('Please choose Google Closure Compiler externs generated by generate-closure-externs.js');
    const input = document.createElement('input');
    input.type = 'file';
    input.onchange = ({target}) => {
      const file = target.files[0];
      const name = file.name;
      const extension = name.split('.').pop().toLowerCase();
      if (extension === 'js') {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsText(file);
      } else {
        alert('Invalid extension .' + extension);
      }
    };
    input.click();
  });

  const processExternObject = (raw_text) => new Promise((resolve) => {
    try {
      eval(raw_text);
    } catch {
      alert('Can not run eval: invalid or unsupported extern file');
      return;
    }
    const name = prompt('Type object name to generate entries');
    try {
      const obj = (new Function([raw_text, `return ${name};`].join('\n')))();
      resolve([name, obj]);
    } catch {
      alert('It looks like object is not exist');
    }
  })
    
  const generateEntries = ([name, obj]) => new Promise((resolve) => {
    let objects = [];
    let functions = [];
    try {
      const generator = (obj, path = [name]) => {
        if (typeof obj === 'object') {
          objects.push(path.join('.'));
          for (const key of Object.keys(obj)) {
            generator(obj[key], [...path, key]);
          }
        } else if (typeof obj === 'function') {
          functions.push(path.join('.'));
        } else {
          alert('Unexpected property type: is it truly output of generate-closure-externs.js?');
          throw 'exception-handled';
        }
      };
      generator(obj);
    } catch (e) {
      if (e !== 'exception-handled') {
        throw e;
      }
    }
    const dots = (str) => {
      const result = str.match(/\./g);
      if (result) {
        return result.length;
      } else {
        return 0;
      }
    }
    objects = objects.sort((a, b) => dots(a) > dots(b) ? 1 : -1);
    const namespaces = objects.filter((namespace) => objects.find((object) => {
      if (object === namespace) {
        return false;
      } else if (object.indexOf(namespace) !== -1) {
        return true;
      } else {
        return false;
      }
    }));
    const interfaces = objects.filter((interface) => !namespaces.includes(interface));
    resolve([name, obj, interfaces, namespaces, functions]);
  });

  const buildTypeDefenition = ([name, obj, interfaces]) => new Promise((resolve) => {

    const writeFunction = (isInterface, name) => (isInterface ? `${name}: any;` : `export function ${name}(...args: any): any;`);
    const writeBlock = (isInterface, name) => (isInterface ? `export class ${name}{` : `export namespace ${name}{`);
    const lines = [];

    const validateName = (name) => {
      if (name === 'default' || name === 'constructor') {
        return false;
      } else if (Number.isInteger(Number(name))) {
        return false;
      } else {
        return true;
      }
    };

    const generator = (obj, path, key, isInterface = false) => {
      if (!validateName(key)) {
        return;
      } else if (typeof obj === 'object') {
        lines.push(writeBlock(interfaces.includes(path.join('.')), key))
        for (const key of Object.keys(obj)) {
          generator(obj[key], [...path, key], key, interfaces.includes(path.join('.')));
        }
        lines.push('}');
      } else {
        lines.push(writeFunction(isInterface, key));
      }
    };

    Object.keys(obj).forEach((key) => generator(obj[key], [name, key], key, interfaces.includes([name, key].join('.'))));

    resolve([name, `declare namespace ${name}{${lines.join('')}}`]);
  });

  const download = (blob, name) => {
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    [a.href, a.download] = [url, name];
    a.click();
    window.URL.revokeObjectURL(url);
  };

  const save = (name, text) => {
      const blob = new Blob([[ 
          "/**",
          ` * @fileoverview Typedefs for ${name} generated by generate-typescript-entries in browser runtime`,
          " * @see https://gist.github.com/tripolskypetr/b9c56202cd98935a49389fb46f77ef19",
          " */",
          `${text}`,
          ""
      ].join("\n")], { type: 'text/javascript;charset=utf-8' });
      download(blob, `${name}.d.ts`);
  };

  global.tsEntries = () => applyUserGesture()
    .then(() => loadClosureExterns())
    .then((text) => processExternObject(text))
    .then(([name, obj]) => generateEntries([name, obj]))
    .then(([name, obj, i]) => buildTypeDefenition([name, obj, i]))
    .then(([name, lines]) => save(name, lines));

})(window);
